# 3643. 排序排列

## 题目信息

**难度：** 中等  
**通过率：** 36.9% (1,378/3.7K)  
**相关标签：** 脑筋急转弯、位运算、数组

---

## 题目描述

给你一个长度为 `n` 的整数数组 `nums`，其中 `nums` 是范围 `[0..n - 1]` 内所有数字的一个**排列**。

你可以在满足条件 `nums[i] AND nums[j] == k` 的情况下交换下标 `i` 和 `j` 的元素，其中 `AND` 表示按位与操作，`k` 是一个非负整数。

返回可以使数组按**非递减**顺序排序的最大值 `k`（允许进行任意次这样的交换）。如果 `nums` 已经是有序的，返回 `0`。

**排列**是数组所有元素的一种重新排列。

### 示例

**示例 1：**
```
输入：nums = [0,3,2,1]
输出：1

解释：
选择 k = 1。交换 nums[1] = 3 和 nums[3] = 1，
因为 nums[1] AND nums[3] == 1，从而得到一个排序后的排列：[0, 1, 2, 3]。
```

**示例 2：**
```
输入：nums = [0,1,3,2]
输出：2

解释：
选择 k = 2。交换 nums[2] = 3 和 nums[3] = 2，
因为 nums[2] AND nums[3] == 2，从而得到一个排序后的排列：[0, 1, 2, 3]。
```

**示例 3：**
```
输入：nums = [3,2,1,0]
输出：0

解释：
只有当 k = 0 时，才能进行排序，因为没有更大的 k 能够满足 
nums[i] AND nums[j] == k 的交换条件。
```

### 约束条件

- `1 <= n == nums.length <= 10^5`
- `0 <= nums[i] <= n - 1`
- `nums` 是从 `0` 到 `n - 1` 的一个排列

---

## 解题思路

### 核心洞察

这是一道**脑筋急转弯**题目，关键在于理解：

1. **交换条件**：只有当 `nums[i] AND nums[j] == k` 时，才能交换位置 `i` 和 `j` 的元素
2. **关键性质**：如果答案为 `k`，那么所有满足 `i AND k == k` 的下标 `i` 都能以下标 `k` 为中继点进行任意交换
3. **答案构造**：答案就是所有需要改变位置的下标 `i` 进行按位与操作的结果

### 算法步骤

1. **检查是否已排序**：如果数组已经有序，直接返回 `0`
2. **找出需要改变的位置**：遍历数组，找出所有 `nums[i] != i` 的位置
3. **计算答案**：将所有需要改变的位置下标进行按位与操作
4. **返回结果**：如果所有位置都不需要改变，返回 `0`；否则返回按位与的结果

---

## 代码实现

### Python3 完整代码

```python
class Solution:
    def sortPermutation(self, nums: List[int]) -> int:
        """
        计算可以使数组排序的最大k值
        
        解题思路：
        1. 如果数组已经有序，返回0
        2. 找出所有需要改变位置的下标i（nums[i] != i）
        3. 将这些下标进行按位与操作，结果就是答案
        
        参数:
            nums: 输入数组，是0到n-1的一个排列
            
        返回:
            可以使数组排序的最大k值
        """
        n = len(nums)
        ans = (1 << 30) - 1  # 初始化为全1（30位）
        flag = True  # 标记数组是否已经有序
        
        # 遍历数组，找出需要改变的位置
        for i in range(n):
            if nums[i] != i:
                # 如果当前位置的值不等于下标，需要改变
                ans &= i  # 与当前下标进行按位与操作
                flag = False  # 标记数组无序
        
        # 如果数组已经有序，返回0；否则返回按位与的结果
        return 0 if flag else ans
```

### 代码解释

#### 关键变量说明

- **`ans`**：初始化为 `(1 << 30) - 1`，即30位全1的二进制数
- **`flag`**：标记数组是否已经有序，初始为 `True`
- **`i`**：当前遍历的下标位置

#### 核心逻辑

1. **初始化**：`ans = (1 << 30) - 1` 创建一个足够大的全1二进制数
2. **遍历检查**：对于每个位置 `i`，检查 `nums[i] != i`
3. **按位与操作**：如果位置 `i` 需要改变，执行 `ans &= i`
4. **结果判断**：如果 `flag` 仍为 `True`，说明数组已有序，返回 `0`；否则返回 `ans`

#### 为什么这样计算是正确的？

- **按位与的性质**：如果 `i AND k == k`，那么 `i` 的所有为1的位在 `k` 中也必须为1
- **交换条件**：只有当两个位置的下标 `i` 和 `j` 都满足 `i AND k == k` 时，才能交换
- **最大k值**：通过按位与操作，我们找到了满足所有需要交换位置的最小公共位模式

---

## 复杂度分析

- **时间复杂度**：O(n)，只需要遍历数组一次
- **空间复杂度**：O(1)，只使用了常数个额外变量

---

## 示例验证

让我们用示例1来验证算法的正确性：

**输入：** `nums = [0,3,2,1]`

**执行过程：**
1. `i = 0`: `nums[0] = 0`，不需要改变，`ans` 保持 `(1 << 30) - 1`
2. `i = 1`: `nums[1] = 3 ≠ 1`，需要改变，`ans &= 1 = 1`
3. `i = 2`: `nums[2] = 2`，不需要改变，`ans` 保持 `1`
4. `i = 3`: `nums[3] = 1 ≠ 3`，需要改变，`ans &= 3 = 1`

**结果：** `ans = 1`，验证了示例1的输出

---

## 学到了什么

### 1. 脑筋急转弯思维
- **跳出常规思维**：不要被复杂的交换条件迷惑
- **寻找关键性质**：理解交换条件的本质含义
- **简化问题**：将复杂的交换问题转化为简单的位运算

### 2. 位运算技巧
- **按位与操作**：`&` 操作可以找出两个数的公共位
- **位模式匹配**：理解 `i AND k == k` 的几何意义
- **初始化技巧**：使用 `(1 << 30) - 1` 创建全1二进制数

### 3. 问题建模能力
- **抽象化思维**：将具体的交换操作抽象为位运算
- **约束条件分析**：理解交换条件的数学含义
- **最优解构造**：通过按位与操作构造满足所有约束的最大值

### 4. 代码优化技巧
- **一次遍历**：避免多次遍历数组
- **标志变量**：使用 `flag` 变量简化逻辑判断
- **位运算优化**：利用位运算的高效性

---

## 总结

这道题是一个典型的**脑筋急转弯**题目，关键在于：

1. **理解交换条件的本质**：`nums[i] AND nums[j] == k` 实际上是对下标的约束
2. **寻找关键性质**：所有需要交换的位置下标必须满足某种位模式关系
3. **构造最优解**：通过按位与操作找到满足所有约束的最大k值

通过这道题，我们学会了如何将复杂的交换问题转化为简单的位运算问题，以及如何利用位运算的性质来构造最优解。

---

## 参考资源

- **题目链接**：`https://leetcode.cn/problems/sort-permutation/`
- **题解参考**：TsReaper（LCCUP 2022 秋季编程大赛战队赛 TOP 1）
- **相关题目**：位运算、脑筋急转弯、数组排序

---

> **注**：本文对原题描述进行结构化整理，代码实现和思路说明为原创整理，旨在帮助理解算法思想和实现细节。