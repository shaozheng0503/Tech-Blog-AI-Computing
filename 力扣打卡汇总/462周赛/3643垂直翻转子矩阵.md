## 3643. 垂直翻转子矩阵

- **难度**: 简单
- **题意**: 给定一个 `m x n` 整数矩阵 `grid`，和正方形子矩阵的左上角坐标 `(x, y)` 以及边长 `k`。请将该正方形子矩阵在“垂直方向”翻转（即上下翻转，行顺序反转），返回更新后的矩阵。

---

### 题目描述（精简）
- 输入: `grid`（`m x n` 矩阵），`x`，`y`，`k`
- 操作: 对以 `(x, y)` 为左上角、边长为 `k` 的“正方形子矩阵”做垂直翻转
- 输出: 翻转后的 `grid`

约束：
- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 50`
- `1 <= grid[i][j] <= 100`
- `0 <= x < m`
- `0 <= y < n`
- `1 <= k <= min(m - x, n - y)`

---

### 示例

- 示例 1：
```
输入: grid = [[1,2,3,4],
             [5,6,7,8],
             [9,10,11,12],
             [13,14,15,16]], x = 1, y = 0, k = 3
输出: [[1,2,3,4],
      [13,14,15,8],
      [9,10,11,12],
      [5,6,7,16]]
```

- 示例 2：
```
输入: grid = [[3,4,2,3],
             [2,3,4,2]], x = 0, y = 2, k = 2
输出: [[3,4,4,2],
      [2,3,2,3]]
```

---

### 思路解析
- 垂直翻转等价于：对子矩阵中的第 `i` 行与第 `k - 1 - i` 行进行整列交换（仅对子矩阵列范围 `y..y+k-1` 内的元素）。
- 可用双指针：`l = x` 指向子矩阵顶部行，`r = x + k - 1` 指向底部行；当 `l < r` 时，遍历列 `j` 从 `y` 到 `y + k - 1`，逐列交换 `grid[l][j]` 与 `grid[r][j]`，随后 `l += 1`，`r -= 1`。
- 原地操作，空间 O(1)。

为什么正确：
- 翻转后子矩阵第 `i` 行应来自翻转前的第 `k - 1 - i` 行（相对子矩阵内部行号）。上述两端向中间的配对交换，正好实现该行映射；列索引不变，仅交换同列元素。

---

### 复杂度分析
- 时间复杂度：`O(k^2)`，需要对 `k/2` 对行、`k` 列做交换。
- 空间复杂度：`O(1)`，原地交换。

---

### 边界与细节
- 当 `k == 1` 时，不需要任何操作（单行翻转等于自身）。
- `(x, y)` 与 `k` 由题目保证合法，无需额外边界判断。
- 注意仅对子矩阵列范围 `[y, y + k - 1]` 内元素交换；其他列不受影响。

---

### 代码（Python，详细注释）
```python
from typing import List

class Solution:
    def reverseSubmatrix(self, grid: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:
        """
        对以 (x, y) 为左上角、边长为 k 的正方形子矩阵执行“垂直翻转”（上下翻转）。
        翻转仅影响子矩阵内部的列范围 [y, y + k - 1]，其余列保持不变。

        参数:
            grid: 原始 m x n 矩阵
            x, y: 子矩阵左上角坐标
            k: 子矩阵边长
        返回:
            原地修改后的 grid，并返回引用（符合 LeetCode 风格）
        """
        # 顶部行指针与底部行指针，限定在子矩阵的行范围 [x, x + k - 1]
        top_row = x
        bottom_row = x + k - 1

        # 当顶部还在底部之上时，成对交换两行在子矩阵列范围内的元素
        while top_row < bottom_row:
            # 仅对子矩阵的列范围 [y, y + k - 1] 做交换
            for col in range(y, y + k):
                # 交换同一列、位于 top_row 与 bottom_row 的元素
                grid[top_row][col], grid[bottom_row][col] = grid[bottom_row][col], grid[top_row][col]
            # 向中间收缩
            top_row += 1
            bottom_row -= 1

        return grid
```

---

### 小测试（可选）
```python
if __name__ == "__main__":
    s = Solution()

    grid1 = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]
    assert s.reverseSubmatrix([row[:] for row in grid1], 1, 0, 3) == [
        [1,2,3,4],
        [13,14,15,8],
        [9,10,11,12],
        [5,6,7,16]
    ]

    grid2 = [[3,4,2,3],[2,3,4,2]]
    assert s.reverseSubmatrix([row[:] for row in grid2], 0, 2, 2) == [
        [3,4,4,2],
        [2,3,2,3]
    ]

    # 边界: k=1，无变化
    grid3 = [[1,2],[3,4]]
    assert s.reverseSubmatrix([row[:] for row in grid3], 0, 0, 1) == [[1,2],[3,4]]
```

---

### 参考
- 题目链接：`https://leetcode.cn/problems/flip-square-submatrix-vertically/`
- 作者：灵茶山艾府（题解参考）

> 注：本文对原题描述进行结构化与精简，代码与思路说明为原创整理。