# 2044. 统计按位或能得到最大值的子集数目

## 题目信息

**难度：** 中等  
**通过率：** 83.2% (46,719/56.1K)  
**相关标签：** 位运算、数组、回溯、动态规划

## 题目描述

给你一个整数数组 `nums`，请你找出 `nums` 子集按位或可能得到的最大值，并返回按位或能得到最大值的不同非空子集的数目。

如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个子集。如果选中的元素下标位置不一样，则认为两个子集不同。

对数组 a 执行按位或，结果等于 `a[0] OR a[1] OR ... OR a[a.length - 1]`（下标从 0 开始）。

## 示例

### 示例 1：
```
输入：nums = [3,1]
输出：2
解释：子集按位或能得到的最大值是 3。有 2 个子集按位或可以得到 3：
- [3]
- [3,1]
```

### 示例 2：
```
输入：nums = [2,2,2]
输出：7
解释：[2,2,2] 的所有非空子集的按位或都可以得到 2。总共有 2³ - 1 = 7 个子集。
```

### 示例 3：
```
输入：nums = [3,2,1,5]
输出：6
解释：子集按位或可能的最大值是 7。有 6 个子集按位或可以得到 7：
- [3,5]
- [3,1,5]
- [3,2,5]
- [3,2,1,5]
- [2,5]
- [2,1,5]
```

## 提示

- 1 <= nums.length <= 16
- 1 <= nums[i] <= 10⁵

## 解题思路

### 核心思想

1. **找到最大值**：将所有数字进行按位或运算，得到所有子集可能达到的最大值
2. **枚举子集**：使用位运算或 DFS 生成所有可能的非空子集
3. **统计结果**：检查每个子集的按位或结果是否等于最大值

### 算法分析

**时间复杂度：**
- 位运算方法：O(2ⁿ × n)
- DFS 方法：O(2ⁿ)

**空间复杂度：**
- 位运算方法：O(1)
- DFS 方法：O(n)（递归调用栈深度）

## 完整代码实现

### 方法一：位运算枚举（推荐）

```python
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        """
        统计按位或能得到最大值的子集数目
        
        解题思路：
        1. 首先找到所有子集按位或可能得到的最大值
        2. 然后统计有多少个不同的非空子集能达到这个最大值
        
        方法：使用位运算枚举所有子集
        """
        
        # 第一步：找到所有子集按位或可能得到的最大值
        max_or = 0
        for num in nums:
            max_or |= num  # 按位或运算，找到所有数字按位或的最大值
        
        # 第二步：统计能达到最大值的子集数量
        count = 0
        n = len(nums)
        
        # 使用位运算枚举所有子集
        # 对于长度为 n 的数组，有 2^n 个子集（包括空集）
        # 我们用二进制数来表示子集的选择情况
        # 例如：nums = [3,1]，n=2
        # 00 表示空集
        # 01 表示选择 nums[1] = 1
        # 10 表示选择 nums[0] = 3  
        # 11 表示选择 nums[0] 和 nums[1] = [3,1]
        
        for mask in range(1, 1 << n):  # 从 1 开始，跳过空集
            current_or = 0
            
            # 检查当前子集中包含哪些元素
            for i in range(n):
                # 如果第 i 位为 1，说明选择了 nums[i]
                if mask & (1 << i):
                    current_or |= nums[i]
            
            # 如果当前子集的按位或结果等于最大值，计数加 1
            if current_or == max_or:
                count += 1
        
        return count
```

### 方法二：DFS 深度优先搜索

```python
class SolutionDFS:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        """
        使用深度优先搜索（DFS）的方法
        这种方法更直观，易于理解
        """
        self.max_or = 0
        self.count = 0
        
        # 计算最大值
        for num in nums:
            self.max_or |= num
        
        # 使用 DFS 生成所有子集
        self.dfs(nums, 0, 0)
        
        return self.count
    
    def dfs(self, nums, index, current_or):
        """
        深度优先搜索生成子集
        
        Args:
            nums: 原始数组
            index: 当前处理的位置
            current_or: 当前子集的按位或结果
        """
        # 如果当前按位或结果等于最大值，计数加 1
        if current_or == self.max_or:
            self.count += 1
        
        # 如果已经处理完所有元素，返回
        if index == len(nums):
            return
        
        # 不选择当前元素
        self.dfs(nums, index + 1, current_or)
        
        # 选择当前元素
        self.dfs(nums, index + 1, current_or | nums[index])
```

### 方法三：带详细调试信息的版本

```python
class SolutionDetailed:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        """
        带详细调试信息的版本，帮助理解算法过程
        """
        print(f"输入数组: {nums}")
        
        # 第一步：计算最大值
        max_or = 0
        for num in nums:
            max_or |= num
        print(f"所有子集按位或可能得到的最大值: {max_or}")
        print(f"二进制表示: {bin(max_or)}")
        print()
        
        count = 0
        n = len(nums)
        
        print("枚举所有非空子集:")
        for mask in range(1, 1 << n):
            # 将 mask 转换为二进制字符串，方便查看
            mask_bin = bin(mask)[2:].zfill(n)
            current_or = 0
            selected_nums = []
            
            for i in range(n):
                if mask & (1 << i):
                    current_or |= nums[i]
                    selected_nums.append(nums[i])
            
            print(f"子集 {mask_bin}: {selected_nums}, 按位或结果: {current_or}", end="")
            
            if current_or == max_or:
                count += 1
                print(" ✓ (达到最大值)")
            else:
                print()
        
        print(f"\n总共有 {count} 个子集能达到最大值 {max_or}")
        return count
```

## 测试代码

```python
def test_solution():
    """测试函数"""
    solution = Solution()
    
    # 测试用例 1
    nums1 = [3, 1]
    result1 = solution.countMaxOrSubsets(nums1)
    print(f"测试用例 1: nums = {nums1}")
    print(f"期望输出: 2, 实际输出: {result1}")
    print(f"测试结果: {'通过' if result1 == 2 else '失败'}")
    print()
    
    # 测试用例 2
    nums2 = [2, 2, 2]
    result2 = solution.countMaxOrSubsets(nums2)
    print(f"测试用例 2: nums = {nums2}")
    print(f"期望输出: 7, 实际输出: {result2}")
    print(f"测试结果: {'通过' if result2 == 7 else '失败'}")
    print()
    
    # 测试用例 3
    nums3 = [3, 2, 1, 5]
    result3 = solution.countMaxOrSubsets(nums3)
    print(f"测试用例 3: nums = {nums3}")
    print(f"期望输出: 6, 实际输出: {result3}")
    print(f"测试结果: {'通过' if result3 == 6 else '失败'}")
    print()

if __name__ == "__main__":
    # 运行测试
    test_solution()
    
    print("=" * 50)
    print("详细版本演示:")
    solution_detailed = SolutionDetailed()
    solution_detailed.countMaxOrSubsets([3, 1])
```

## 关键知识点

### 1. 按位或运算（Bitwise OR）
- 符号：`|`
- 特点：只要有一个位为 1，结果就为 1
- 性质：按位或运算具有单调性，添加更多元素不会减少结果

### 2. 位运算枚举子集
- 使用二进制数的每一位表示是否选择对应位置的元素
- `mask & (1 << i)` 检查第 i 位是否为 1
- `1 << n` 表示 2ⁿ

### 3. 子集生成
- 对于长度为 n 的数组，有 2ⁿ 个子集
- 包括空集，所以非空子集数量为 2ⁿ - 1

## 优化技巧

1. **提前计算最大值**：避免重复计算
2. **位运算优化**：使用位运算进行子集枚举
3. **剪枝优化**：在 DFS 中，如果当前结果已经达到最大值，可以提前返回

## 相关题目

- [78. 子集](https://leetcode.cn/problems/subsets/)
- [90. 子集 II](https://leetcode.cn/problems/subsets-ii/)
- [1863. 找出所有子集的异或总和再求和](https://leetcode.cn/problems/sum-of-all-subset-xor-totals/)

---

**面试中遇到过这道题？** 1/5 是 | 否