
上下文工程指南
上下文工程指南
由 DAIR 提供。AI 学院


目录

什么是情境工程？
情景工程的实际应用
系统提示符
指示
用户输入
结构化输入和输出
工具调用
RAG & 内存
状态和历史背景
高级上下文工程
资源


什么是情境工程？
几年前，许多，甚至是顶级 AI 研究人员，声称提示工程现在已经死了。

显然，他们大错特错了，事实上，及时的工程设计现在比以往任何时候都更加重要。它非常重要，以至于它现在被重新命名为上下文工程。

是的，这是另一个花哨的术语，用于描述 LLM 有效执行其任务所需的指令和相关上下文的重要过程。

关于上下文工程（Ankur Goyal、Walden Yan、Tobi Lutke 和 Andrej Karpathy）已经写了很多文章，但我想写下我对这个主题的想法，并向您展示一个具体的分步指南，将上下文工程付诸实践，以开发 AI 代理工作流程。

我不完全确定是谁创造了情境工程，但我们将以 Dex Horthy 的这个数字为基础，它简要解释了什么是情境工程。

图像

我喜欢上下文工程这个术语，因为它感觉像是一个更广泛的术语，可以更好地解释提示工程中的大部分工作，包括其他相关任务。

关于提示工程是一项严肃技能的怀疑在于，许多人将其与盲目提示（您在 ChatGPT 等 LLM 中使用的简短任务描述）混淆。在盲提示中，您只是向系统提出了一个问题。在提示工程中，您必须更仔细地考虑提示的上下文和结构。也许它应该从一开始就被称为上下文工程。

上下文工程是下一阶段，在该阶段中，您需要构建完整的上下文，在许多情况下，这需要超越简单的提示，并采用更严格的方法来获取、增强和优化系统知识。

从开发人员的角度来看，上下文工程涉及一个迭代过程，以优化说明和您为 LLM 提供的上下文以实现所需的结果。这包括制定正式的流程（例如，评估管道）来衡量您的策略是否有效。

鉴于 AI 领域的快速发展，我建议对上下文工程进行更广泛的定义：为 LLM 和高级 AI 模型设计和优化指令和相关上下文以有效执行其任务的过程。 这不仅包括基于文本的 LLM，还包括优化多模态模型的上下文，这些模型正变得越来越普遍。这可以包括所有及时的工程工作和相关流程，例如：

设计和管理提示链（如果适用）
优化说明/系统提示
管理提示的动态元素（例如，用户输入、日期/时间等）
搜索和准备相关知识（即 RAG）
查询扩充
工具定义和说明（在代理系统的情况下）
准备和优化小样本演示
构建输入和输出（例如，分隔符、JSON 架构）
短期记忆（即管理状态/历史背景）和长期记忆（例如，从向量存储中检索相关知识）
以及许多其他有助于优化 LLM 系统提示以实现所需任务的技巧。
换句话说，您在上下文工程中尝试实现的是优化您在 LLM 的上下文窗口中提供的信息。这也意味着过滤掉嘈杂的信息，这本身就是一门科学，因为它需要系统地衡量 LLM 的性能。

每个人都在撰写有关上下文工程的文章，但在这里，我们将向您介绍一个具体示例，说明在构建 AI 代理时上下文工程是什么样子的。


情景工程的实际应用
让我们看一个具体的例子，我最近为我为个人使用构建的多智能体深度研究应用程序所做的一些上下文工程工作。

我在 n8n 中构建了代理工作流，但工具并不重要。我构建的完整代理体系结构如下所示：



我的工作流程中的 Search Planner 代理负责根据用户查询生成搜索计划。

系统提示符
以下是我为这个 subagent 整理的系统提示符：

您是一位 专业的研究规划师。 您的任务是 分解 一个复杂的研究查询（以 <user_query></user_query> 分隔） 到特定的搜索子任务中，每个子任务都侧重于 不同的方面或源类型。

       

当前日期和时间 为：{{ $now.toISO（） }}


对于每个子任务，请提供：

1. 子任务的唯一 字符串 ID（例如，'subtask_1'、'news_update”）

2. 专注于 主查询的一个方面的 特定搜索查询

3. 要搜索的来源类型（网络、新闻、学术、专业）

4. 时间段 相关性（今天、上周、最近、past_year、all_time）

5. 领域重点（如果适用）（技术、科学、健康等）

6. 优先级（1 到 最低 5）

       

每个子任务都需要所有字段（id、query、source_type、time_period、domain_focus、priority）， 但 time_period 和 domain_focus，如果不适用，则可以 为 null。

       

创建 2 个子任务，它们将共同提供主题的全面 覆盖。 关注不同的方面、观点或 信息来源 。


每个子任务将包含 以下信息：


ID：str

查询：str

source_type： str # 例如， “web”， “news”， “academic”， “specialized”

time_period： 可选[str] = 无 # 例如， “today”， “last week”， “recent”， “past_year”， “all_time”

domain_focus： Optional[str] = None # 例如， “technology”， “science”， “health”

优先级：int # 1（最高）到 5（最低）


获取上述 subtasks 信息后，您将 添加两个额外的字段。 这些对应于 start_date 和 end_date。 根据 当前日期和 所选time_period推断此信息 。 start_date 和 end_date 应使用 以下示例中的 格式：


“start_date”： “2024-06-03T06：00：00.000Z”，

“end_date”： “2024-06-11T05：59：59.999Z”，

此提示的许多部分都需要仔细考虑我们为规划代理提供的确切上下文来有效执行任务。如您所见，这不仅仅是设计一个简单的提示或说明;此过程需要实验，并为模型提供重要的上下文，以便以最佳方式执行任务。

让我们将问题分解为核心组件，这些组件是有效上下文工程的关键。

指示
指令是提供给系统的高级指令，用于指示它确切地执行什么作。

您是一位 专业的研究规划师。 您的任务是 分解 一个复杂的研究查询（以 <user_query></user_query> 分隔） 到特定的搜索子任务中，每个子任务都侧重于 不同的方面或源类型。

许多初学者，甚至是经验丰富的 AI 开发人员都会在这里停下来。鉴于我分享了上面的完整提示，您可以理解我们需要为系统提供多少上下文才能使其按我们想要的方式工作。这就是上下文工程的全部意义所在;它告诉系统更多关于问题范围和我们究竟希望从中得到什么的细节。

用户输入
用户输入未显示在系统提示符中，但下面是其外观的示例。

<user_query>OpenAI 的最新 开发新闻是什么 ？ </user_query>

注意分隔符的使用，这是为了更好地构建提示。这对于避免混淆非常重要，并更清楚地了解用户输入是什么以及我们希望系统生成什么内容。有时，我们输入的信息类型与我们希望模型输出的内容有关（例如，查询是输入，子查询是输出）。

结构化输入和输出
除了高级说明和用户输入之外，您可能已经注意到，我在与规划代理需要生成的子任务相关的细节上花费了大量精力。以下是我提供给规划代理的详细说明，用于根据用户查询创建子任务。

对于每个 子任务，提供：

1. 子任务的唯一 字符串 ID（例如，'subtask_1'、'news_update”）

2. 专注于 主查询的一个方面的 特定搜索查询

3. 要搜索的来源类型（网络、新闻、学术、专业）

4. 时间段 相关性（今天、上周、最近、past_year、all_time）

5. 领域重点（如果适用）（技术、科学、健康等）

6. 优先级（1 到 最低 5）

       

每个子任务都需要所有字段（id、query、source_type、time_period、domain_focus、priority）， 但 time_period 和 domain_focus，如果不适用，则可以 为 null。

       

创建 2 个子任务，它们将共同提供主题的全面 覆盖。 关注不同的方面、观点或 信息来源 。

如果您仔细查看上面的说明，我决定构建一个我希望规划代理生成的所需信息列表，以及一些提示/示例，以更好地帮助指导数据生成过程。这对于为代理提供有关预期内容的额外上下文至关重要。例如，如果您不告诉它您希望优先级的等级为 1-5，则系统可能更喜欢使用 1-10 的等级。同样，这个背景很重要！

接下来，我们来谈谈结构化输出。为了从 Planning Agent 获得一致的输出，我们还提供了一些关于我们期望的 subtask 格式和字段类型的上下文。下面是我们作为附加上下文传递给代理的示例。这将为代理提供关于我们期望的输出的提示和线索：

每个子任务将包含 以下信息：


ID：str

查询：str

source_type： str # 例如， “web”， “news”， “academic”， “specialized”

time_period： 可选[str] = 无 # 例如， “today”， “last week”， “recent”， “past_year”， “all_time”

domain_focus： Optional[str] = None # 例如， “technology”， “science”， “health”

优先级：int # 1（最高）到 5（最低）

除此之外，在 n8n 中，您还可以使用工具输出解析器，它本质上将用于构建最终输出。我使用的选项是提供一个 JSON 示例，如下所示：

{

  “subtasks”： [

    {

      “id”： “openai_latest_news”，

      “query”： “最新的 OpenAI 公告和新闻”，

      “source_type”： “新闻”，

      “time_period”： “最近”，

      “domain_focus”： “技术”，

      “priority”： 1，

      “start_date”： “2025-06-03T06：00：00.000Z”，

      “end_date”： “2025-06-11T05：59：59.999Z”

    },

    {

      “id”： “openai_official_blog”， //

      “query”： “OpenAI 官方博客最近的帖子”，

      “source_type”： “web”，

      “time_period”： “最近”，

      “domain_focus”： “技术”，

      “priority”：2、

      “start_date”： “2025-06-03T06：00：00.000Z”，

      “end_date”： “2025-06-11T05：59：59.999Z”

    },

...

}

然后，该工具将从这些示例自动生成架构，这反过来又允许系统解析和生成适当的结构化输出，如以下示例所示：

[

  {

    “action”： “解析”，

    “response”： {

      “output”： {

        “subtasks”： [

          {

            “id”： “subtask_1”，

            “query”： “OpenAI 最近的公告或新闻或更新”，

            “source_type”： “新闻”，

            “time_period”： “最近”，

            “domain_focus”： “技术”，

            “priority”： 1，

            “start_date”： “2025-06-24T16：35：26.901Z”，

            “end_date”： “2025-07-01T16：35：26.901Z”

          },

          {

            “id”： “subtask_2”， //

            “query”： “OpenAI 官方博客或新闻稿”，

            “source_type”： “web”，

            “time_period”： “最近”，

            “domain_focus”： “技术”，

            “priority”：1.2、

            “start_date”： “2025-06-24T16：35：26.901Z”，

            “end_date”： “2025-07-01T16：35：26.901Z”

          }

        ]

      }

    }

  }

]

这些东西看起来很复杂，但今天的许多工具都支持开箱即用的结构化输出功能，因此您可能不需要自己实现它。N8n 使上下文工程的这一部分变得轻而易举。这是上下文工程的一个被低估的方面，我看到许多 AI 开发人员出于某种原因而忽略了它。希望上下文工程能更多地阐明这些重要技术。这是一种非常强大的方法，尤其是当您的代理获得不一致的输出时，这些输出需要以特殊格式传递到工作流程中的下一个组件。

工具
我们正在使用 n8n 来构建我们的代理，因此很容易将当前日期和时间放在上下文中。您可以这样做：

当前日期和时间 为：{{ $now.toISO（） }}

这是一个在 n8n 中调用的简单、方便的函数，但通常将其构建为专用工具，以帮助使事情更加动态（即，仅在查询需要时获取日期和时间）。这就是情境工程的意义所在。它迫使您（构建者）就要传递的上下文以及何时将其传递给 LLM 做出具体决定。这很好，因为它消除了应用程序中的假设和不准确之处。

日期和时间是系统的重要上下文;否则，它往往不能很好地处理需要了解当前日期和时间的查询。例如，如果我让系统搜索上周发生的来自 OpenAI 的最新开发新闻，它只会猜测日期和时间，这将导致次优查询，从而导致 Web 搜索不准确。当系统具有正确的日期和时间时，它可以更好地推断日期范围，这对于搜索代理和工具非常重要。我将此作为上下文的一部分添加，以允许 LLM 生成日期范围：

获取上述 subtasks 信息后，您将 添加两个额外的字段。 这些对应于 start_date 和 end_date。 根据 当前日期和 所选time_period推断此信息 。 start_date 和 end_date 应使用 以下示例中的 格式：


“start_date”： “2024-06-03T06：00：00.000Z”，

“end_date”： “2024-06-11T05：59：59.999Z”，

我们专注于架构的规划代理，因此不需要在此处添加太多工具。唯一有意义的其他工具是检索工具，该工具可在给定查询的情况下检索相关子任务。让我们在下面讨论这个想法。

RAG & 内存
我构建的深度研究应用程序的第一个版本不需要使用短期内存，但我们已经构建了一个版本，可以缓存不同用户查询的子查询。这对于在工作流程中实现一些加速/优化非常有用。如果用户之前已经使用过类似的查询，则可以将这些结果存储在向量存储中并搜索它们，以避免为我们已经生成并存在于向量存储中的计划创建一组新的子查询。请记住，每次调用 LLM API 时，都会增加延迟和成本。

这是聪明的上下文工程，因为它使您的应用程序更动态、更便宜、更高效。你看，上下文工程不仅仅是优化你的提示;这是关于为你的目标选择正确的背景。您还可以更有创意地了解如何维护该 vector store 以及如何将这些现有子任务提取到上下文中。创意和新颖的上下文工程是护城河！

国家和历史背景
我们没有在 deep research 代理的 v1 中展示它，但该项目的一个重要部分是优化结果以生成最终报告。在许多情况下，代理系统可能需要修改所有或一部分查询、子任务，以及可能从 Web 搜索 API 中提取的数据。这意味着系统将对问题进行多次尝试，并且需要访问以前的状态，并且可能需要访问系统的所有历史上下文。

这在我们的用例中意味着什么？在我们的示例中，它可以为代理提供对子任务状态、修订（如果有）、工作流中每个代理的过去结果以及在修订阶段提供帮助所需的任何其他上下文的访问权限。对于这种类型的上下文，我们传递的内容将取决于您要优化的内容。这里将发生很多决策。上下文工程并不总是那么简单，我认为你可以开始想象这个组件需要多少次迭代。这就是为什么我继续强调其他领域的重要性，例如评估。如果你没有测量所有这些东西，你怎么知道你的情境工程工作是否有效？


高级上下文工程 [WIP]
本文没有介绍上下文工程的许多其他方面，例如上下文压缩、上下文管理技术、上下文安全和评估上下文有效性（即，测量上下文随时间推移的有效性）。我们将在以后的文章中分享有关这些主题的更多想法。

上下文可能会稀释或变得低效（即，充满陈旧和不相关的信息），这需要特殊的评估工作流程来捕获这些问题。

我预计上下文工程将继续发展成为 AI 开发人员/工程师的一组重要技能。除了手动上下文工程之外，还有机会构建自动化处理有效上下文工程的方法。我看到了一些尝试这样做的工具，但在这个领域还需要有更多的进展。

资源
以下是其他最近撰写有关情境工程的文章的一些推荐读物：

https://www.promptingguide.ai/
https://rlancemartin.github.io/2025/06/23/context_engineering/
https://x.com/karpathy/status/1937902205765607626
https://www.philschmid.de/context-engineering
https：//simple.ai/p/the-skill-that's-replacing-prompt-engineering？
https://github.com/humanlayer/12-factor-agents
https://blog.langchain.com/the-rise-of-context-engineering/
如果您想采取下一步行动，我想推荐我的课程，我在其中使用实践方法涵盖了其中的许多领域：



使用优惠券AGENTS30可享受 Pro 会员资格 30% 的折扣。

立即注册

我还将在 2025 年 7 月 31 日为我们的 Pro 会员举办一个关于上下文工程的研讨会。希望在那里见到你们中的一些人。

如果您在本文中看到任何错误，请联系我们。



