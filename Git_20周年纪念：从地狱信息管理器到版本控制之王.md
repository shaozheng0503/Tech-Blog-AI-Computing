# Git 20 周年纪念：从地狱信息管理器到版本控制之王

> 原文：[Git's 20 years. Still weird, still wonderful.](https://gitbutler.com/blog/git-20-years)  
> 作者：Scott Chacon（GitHub 联合创始人、GitButler 联合创始人）

20 年前的今天，Linus Torvalds 对 Git 做出了第一个提交，这个来自地狱的信息管理器就此诞生。

在过去的 20 年里，Git 从一个简单的小型个人项目，发展成为有史以来规模最大的版本控制系统。

我个人在这个软件过山车上经历了地狱般的旅程。我在 Git 第一次提交后几个月就开始使用它，用于你可能想象不到的目的。然后，我参与创立了 GitHub，写了可能是 Git 领域阅读最广泛的书，建立了项目的官方网站，发起了年度开发者大会，等等——这个小项目不仅改变了软件开发的世界，更极大地改变了我的人生轨迹。

今天，随着 Git 项目进入第三个十年，我想回顾一下 Git 的早期发展历程，解释为什么我觉得这个项目如此迷人。

## 1. 补丁和压缩包的年代

在讨论 Git 的历史以及我与它的关系之前，我想先谈谈 Git 诞生的原因以及它最初的设计思路。

Git 源于 Linux 内核开发社区对版本控制和协作的挫败感。

内核社区一直使用邮件列表进行协作。这实际上是一种非常迷人的协作方法——它具备可扩展性、高度分布式、本地优先、能够对补丁进行细粒度讨论、加密安全等特性。

邮件列表协作流程的核心是：

- 发布项目已知状态的压缩包（类似 zip 文件）
- 人们下载并在本地解压
- 使用任何想要的功能或修复对其进行修改
- 运行 GNU diff 创建补丁，维护者可以将其应用到初始已知状态以添加该功能
- 通过电子邮件将该补丁或一系列补丁发送到邮件列表
- 列表讨论这些变化
- 维护者为下一个压缩包版本应用补丁或要求更改
- 重复这个过程

我很想写一整篇博文来介绍邮件列表协作是如何工作的，以及它的各个方面有多酷，但那是另一个话题了。

然而，在那个时代，当时的版本控制系统根本没有帮助——它们似乎在功能上倒退了。它们有笨拙的访问控制机制，不是分布式的，而且速度非常慢。

社区主要使用补丁和压缩包，现有的 SCM（软件配置管理）工具还不够好。

如果你仔细想想，补丁和压缩包工作流程有点像第一个分布式版本控制系统——每个人都有一个本地副本，更改可以在本地进行，对"合并"的访问是可以将新压缩包推送到服务器的人。

然而，这个过程仍然有点麻烦——管理补丁、记住应用的内容和贡献者、保持多个系列的运行、处理冲突或重新设置更改的基数。

Bitkeeper 工具是专门为内核的用例开发的，旨在尝试构建适用于此工作流程的版本控制系统，Linus 确实喜欢它，但他们想要使用的许可与它所针对的社区不符。

重要的是要明白这就是创建 Git 的原因。不是真的成为一个版本控制系统，而是从根本上成为做补丁和压缩包的更好方式——快照一组文件并显示可以讨论的差异。

这主要是它的数据结构设计方式（文件树的链接列表、内容可寻址的 blob 存储），并且从第一次提交到今天，该结构基本上没有变化。

## 2. 第一次提交

既然我们谈到了这个话题，那么第一次提交是什么样的？Git 从它存在的第一刻起能做什么？

嗯，这是一个愚蠢的内容跟踪器。正如 Linus 本人从第一天起就说的那样：

> 这是一个愚蠢（但非常快）的目录内容管理器。它的作用不大，但它的作用是有效地跟踪目录内容。

第一次提交是 7 个简单的独立工具的集合。它们不是像 `git commit`，而是像 `write-tree` 和 `commit-tree` 这样的非常低级的数据库工具（这在项目开始几周后发生了变化，当所有内容都开始以 `git-` 为前缀时）。

其中一些演变成仍然存在的管道命令，如 `git cat-file` 和 `git write-tree`，其他的则从根本上不同（例如，`read-tree` 是当前的 Git 管道命令，但原来的更像是当前的 `git ls-files`），但是，在低层次上，这些概念仍然存在。

从本质上讲，在第一次提交时，Git 可以：

- 通过使用 `update-cache` 构建内容缓存（本质上是一个压缩包）来构建一个"快照"，并将其作为对象写入数据库
- 编写一个"变更集"（commit），并评论新压缩包引入的更改及其所基于的父级，以便设置"压缩包"的历史记录
- 使用 `cat-file`（从数据库中提取对象）、`read-tree`（列出缓存的外观）和 `show-diff`（显示缓存与工作目录的差异）读出这些数据库结构

从第一天开始，Linus 就提到他真的只想构建这个管道，并让它成为一些 UI（"瓷器"）的后端，并在其上编写脚本。

> 这就是我个人一直认为的"git"是什么，只是表面下的管道。例如，像 arch 这样基于"patches and tar-balls"的东西（我认为 darcs 在这方面很相似），可以将 git 用作更好的"tar-balls历史"的 _hell_ 。——Linus

他的意思是构建一个高效的压缩包历史数据库工具集，而不是真正的版本控制系统。他假设其他人会编写该层。

## 3. Scott 遇见 Git

我个人第一次接触到 Git 是在时间线的这个时间点，由我的朋友和同事 Nick Hengeveld 介绍的，当时我们俩都在一家命运多舛的创业公司 Reactrix 工作。

Nick 和我负责将这些互动广告的资产放到全国各地的商场和剧院的电脑上。

有趣的是，我们更多地按照 Linus 对工具的看法来使用 Git——作为一个分布式内容跟踪器——而不是你今天可能主要认为的版本控制系统。

我们基本上为一家广告公司工作，该公司管理着一堆具有相当重量级资产的数字标牌显示器。我们数百个显示器中的每一个都有他们需要投放的独特广告组合，大多数都在慢速蜂窝数据上行链路上，并且广告变化很大。因此，我们需要一种有效的方式来表示"对于机器 A，我们需要广告 1、2 和 3（v1）。对于机器 B，我们需要广告 2、3（v2）和 4"，如果现有广告有新版本，我们会逐步更新它们。

我们使用 Git——不是为了跟踪源代码中的更改，而是一种内容分发机制。我们将使用脚本来查看即将到来的计划，只写出每台机器需要的广告的唯一树，将该树提交到机器的分支，然后让每台机器每晚获取和硬结账。

这种方法有很多有趣的优势：

- 如果广告更新，我们只传输更改的文件，并且更改会针对计算机上可能已存在的对象进行增量压缩
- 所有共享资产都有一个可以在多个上下文中结账的 blob——Git 的内容可寻址文件系统方面非常适合这一点
- 我们可以拥有数百种资产的数千种组合，而无需在任何地方两次存储任何内容，也不用在网络上多次传输相同的内容

Nick 是早期 Git 项目的一个相当大的贡献者，以使其适用于我们的用例（为 http-fetch 添加 SSL 支持、添加可恢复和并行 HTTP 传输、第一个基于 HTTP 的推送解决方案等）。他的第一个补丁是在 9 月，距离 Linus 第一次提交仅 6 个月。

他向我介绍了 Git，我努力掌握它，以及我最终认为它很酷的灵光一闪，这些都是促使我写下它并试图让人们更容易学习的原因。

这促使我编写了 Git 社区手册、Git Internals Peepcode PDF、构建 git-scm.com 网站并编写了 Pro Git 书籍——所有这些都最终将我带到了 GitHub。

## 4. Git 传说

那么，这个愚蠢的内容跟踪器是如何成为世界上使用最广泛的 SCM 的呢？

好吧，我在之前的博客文章中回顾了我认为 Git 和 GitHub"获胜"的许多原因，但我确实认为值得快速浏览一下为什么 Git 本身最终会变成今天的样子。也可以讲述一些有趣的轶事，关于您一路上所知道和喜爱的事物的起源。

正如您可能已经从 Git 命令偶尔不友好、晦涩或不一致的性质推断的那样，这并不是一个从第一天起就有人坐下来从可用性角度精心设计的系统。

在最初的几个月里，git 命令都是非常低级的——即使你知道现有的底层命令，你也可能认不出 2005 年 6 月存在的命令中的任何一个（`rev-tree`、`mkdelta`、`tar-tree`？）

从一开始就很清楚，这种方法是 Git 只是一个非常低级的数据库/文件系统类型工具集，并且（可能几个）其他工具将使用 Git 作为他们的基础设施。

> 为避免混淆，将基于 git 构建的 SCM 与 git 本身区分开来可能是值得的。其他 SCM 可能会在以后开发，基于 git 构建，这些 SCM 可以想出自己聪明的名字。——Steven Cole

因此，如果 Linus 和早期的 Git 团队最初并没有想象 Git 是一个实际的版本控制工具，而只是想构建管道，那么我们今天所知道的"瓷器"命令实际上来自哪里呢？

答案是，它们在几年内慢慢地进入了自己的状态，主要是作为 shell 脚本，这些脚本不断发展以解决一系列问题。

在早期，有许多用户界面为 Linus 的后端工具编写脚本，使其更加用户友好。最早也是最初几年最受欢迎的是 `git-pasky`，它很快成为 Petr Baudis 的"Cogito"。这些脚本的第一个版本在 Git 发布几天后才发布。

在早期的发布公告中，您可以感受到即将成为 Git 的工具。

几个月后，随着 git 中的工具开始与瓷器脚本中的工具竞争，试图保持瓷器和管道之间的界限开始瓦解。

这种趋势始于为了裸露管道的可用性而添加"git diff"、"git commit"和朋友。这些基本命令是必须的，我不反对将它们放在"核心 GIT"套件中，但与此同时，我认为核心不应该与瓷器竞争，并觉得应该在某个地方划一条线。——Junio

在接下来的一两年里，越来越多的脚本继续进入核心 Git 代码，直到最终发现，人们的时间最好花在与 Git 一起分发的工具上，而不是试图在工具中保持这种管道/瓷器的区别。

2007 年，Cogito 终于"挂牌出售"，而将其他瓷器作为 Git 主要使用方式的想法或多或少被放弃了。

回顾 20 年前的这些提交和电子邮件，看到我们许多人每天都在使用的一些臭名昭著的工具的诞生令人着迷。

### 第一个 git log

`git log` 的第一个版本是一个包装脚本，它调用 `git-rev-list --pretty`，通过寻呼机通过管道传输它，并被硬编码为从 `HEAD` 开始。这是原始的"git log"程序的完整内容：

```bash
#!/bin/sh
git-rev-list --pretty HEAD | LESS=-S ${PAGER:-less}
```

💡 如果你还没听说过，`rev-list` 是一个简单的遍历器，只是打印出 shas。它仍然存在——你现在仍然可以在你的项目中运行 `git rev-list`。

实际上，目前的很多命令都是以这种方式开始的——几行长的 shell 或 Perl 脚本，运行一些核心的管道命令。最终，几乎所有内容都用 C 语言重写为可移植性的内置函数，但这些脚本语言中有很多命令的初版。

第一个"git log"看起来非常熟悉。

### 第一个 git rebase

这样的"第一次"有很多，但我只再做一个，因为我觉得它太有趣了。臭名昭著的"rebase"命令诞生于 2005 年 6 月 Junio 和 Linus 之间关于工作流程的对话。

Junio 告诉 Linus 他的工作流程是怎样的：

> 仅供参考，这是我一直在做的事情：
> 
> （1）从 Linus HEAD 开始。
> （2）重复 Develop and Commit 循环。
> （3）运行 git format-patch（不在 Linus 树中）生成补丁。
> （4）把他们送出去，等着看哪一个坚持下去。
> （5）从 Linus 拉取。
> （6）扔掉我的 HEAD，让 Linus 成为我的 HEAD，同时保留我从他那里分叉后所做的更改。为此，我使用"jit-rewind"。
> （7）检查 Linus 拒绝的补丁，并应用我仍然认为好的补丁，每个补丁提交一次。为此，我使用了"jit-patch"和"jit-commit -m"。
> （8）返回步骤 2。

Linus 评论说，开发人员在这里真正想要的合并类型是"re-base"工作：

> 它有点类似于当前的 git-merge-script，但它不是基于公共父级合并它，而是尝试将公共父级开始的所有本地提交重新放在新的远程头上。从想要将其工作更新到远程头的个人开发人员的角度来看，这通常更有意义。

然后，Junio 使用一个简单的脚本进行响应，以使用一个名为"re-base"的"re-base"一系列提交。

据我所知，这是"rebase"一词第一次在版本控制中使用。看到历史诞生很有趣。

### "章鱼"是如何成为 Git 的一部分的？

我曾多次被问到 GitHub 从哪里想出了"Octocat"，答案也在于这些早期的档案。

我在 Git 邮件列表中看到的"octopus"这个词的第一个用法是 Junio 告诉 Linus 他的补丁是按顺序应用的，而不是"octopus"。

这指的是创建一个具有多个父级的合并提交，这是不同补丁可能被合并的另一种方式。最终，"octopus merge"成为 Git 箭袋中的有效合并策略之一。（有趣的事实，Git 曾经有"stupid"作为合并策略）

在 GitHub 非常早期的某个时候，Tom 正在寻找任何可以拟人化地用作 Git 图腾的东西，而"Octopus"是 Git 词汇表中唯一似乎符合要求的术语。Tom 搜索了以"octopus"为特色的剪贴画，这张 Simon Oxley 图像是最符合要求的可爱图像。因此，"octocat"诞生了。

## 5. Git 的未来

20 年零一天后，人们可能会问这个不太可能的英雄的未来是什么。

有趣的是，我仍然以某种方式使用 Git，就像它最初打算的那样。GitButler 不仅使用 Git 来跟踪代码更改的正常提交，还使用 git 数据库来跟踪项目的历史。最终，它仍然是一个该死的好愚蠢内容跟踪器，正如 Linus 最初打算的那样。

所以，生日快乐 Git。你仍然很奇怪。你仍然很棒。感谢所有的鱼。

---

**关于作者**：Scott Chacon 是 GitHub 和 GitButler 的联合创始人，在那里他构建现代版本控制的创新工具。他撰写了 Pro Git 并在全球范围内就 Git 和软件协作发表演讲。 